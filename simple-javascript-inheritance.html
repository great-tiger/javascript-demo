<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>jquery之父 john resig 讲解继承</title>
</head>
<body>

    <script>
        /*
        *
        * 引用：
        * http://ejohn.org/blog/simple-javascript-inheritance/
        * http://www.cnblogs.com/enein/archive/2012/12/03/2799160.html
        *
        *
        *
        *
        **/

    </script>



    <script>
        <!--如何使用-->
        var Person = Class.extend({
            init: function(isDancing){
                this.dancing = isDancing;
            },
            dance: function(){
                return this.dancing;
            }
        });

        var Ninja = Person.extend({
            init: function(){
                this._super( false );
            },
            dance: function(){
                // Call the inherited version of dance()
                return this._super();
            },
            swingSword: function(){
                return true;
            }
        });

        var p = new Person(true);
        p.dance(); // => true

        var n = new Ninja();
        n.dance(); // => false
        n.swingSword(); // => true

        // Should all be true
        p instanceof Person && p instanceof Class &&
        n instanceof Ninja && n instanceof Person && n instanceof Class
    </script>

    <script type="text/javascript">
        /* Simple JavaScript Inheritance
         * By John Resig http://ejohn.org/
         * MIT Licensed.
         */
        // Inspired by base2 and Prototype
        (function(){
            var initializing = false,
                    //如果浏览器支持函数序列化，则返回第一个正则，否则返回第二个正则。
                    //typeof prop[name] == "function" &&typeof _super[name] == "function" && fnTest.test(prop[name])
                    //该判断的作用就是，是否需要处理函数重载。
                    fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;

            // The base Class implementation (does nothing)
            this.Class = function(){};

            // Create a new Class that inherits from this class
            Class.extend = function(prop) {
                var _super = this.prototype;

                // Instantiate a base class (but only create the instance,
                // don't run the init constructor)
                initializing = true;//控制构造函数init是否被调用。new this() 的时候，构造函数不需要被调用
                var prototype = new this();
                initializing = false;

                // Copy the properties over onto the new prototype
                for (var name in prop) {
                    // Check if we're overwriting an existing function
                    prototype[name] = typeof prop[name] == "function" &&
                    typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                            (function(name, fn){
                                return function() {
                                    var tmp = this._super;

                                    // Add a new ._super() method that is the same method
                                    // but on the super-class
                                    this._super = _super[name];

                                    // The method only need to be bound temporarily, so we
                                    // remove it when we're done executing
                                    var ret = fn.apply(this, arguments);
                                    this._super = tmp;

                                    return ret;
                                };
                            })(name, prop[name]) :
                            prop[name];
                }

                // The dummy class constructor
                function Class() {
                    // All construction is actually done in the init method
                    if ( !initializing && this.init )
                        this.init.apply(this, arguments);
                }

                // Populate our constructed prototype object
                Class.prototype = prototype;

                // Enforce the constructor to be what we expect
                Class.prototype.constructor = Class;

                // And make this class extendable
                Class.extend = arguments.callee;

                return Class;
            };
        })();
    </script>

    <script>

        <!--A 继承于 B 的最简单的写法 -->


        function A(){

        }

        function B(){

        }


        B.prototype=new A();
        B.constructor=B;



    </script>

</body>
</html>